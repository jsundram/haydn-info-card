import json
import os
from reportlab.lib import colors
from collections import defaultdict, Counter

""""
Generate a Haydn QR-Code
import segno
segno.make('https://quartetroulette.com/Haydn/')
qrcode = segno.make('https://quartetroulette.com/Haydn/')
qrcode.save('quartet-roulette-haydn-qr.png', dark="#111011", light="#5dcbf5", scale=10)
qrcode.save('quartet-roulette-haydn-qr3.png', light="#FFFFFF", data_dark="#5dcbf5", dark='#B82327', scale=10)
"""
CMAP = None
COLS = None

def _accidentals(q):
    k = _key(q)
    # sharps:
    major_s = 'C G D A E B F&sharp; C&sharp;'.split(' ')
    major_sharps = {key: i for (i, key) in enumerate(major_s)}
    major_f = 'C F B&flat; E&flat; A&flat; D&flat; G&flat; C&flat;'.split(' ')
    major_flats = {key: i for (i, key) in enumerate(major_f)}


    # flats
    minor_f = 'a d g c f b&flat; e&flat;'.split(' ')
    minor_flats = {key: i for (i, key) in enumerate(minor_f)}
    minor_s = 'a e b f&sharp; c&sharp; g&sharp; d&sharp;'.split(' ')
    minor_sharps = {key: i for (i, key) in enumerate(minor_s)}
    # print("Sharps:\nmajor: %s\nminor: %s" % (major_sharps, minor_sharps))
    # print("Flats:\nmajor: %s\nminor: %s" % (major_flats, minor_flats))
    return major_sharps.get(k, 0) + minor_sharps.get(k, 0) - \
           minor_flats.get(k, 0)  - major_flats.get(k, 0)


def _title(q):
    opus, n = q['opus'], q.get('#', None)
    if n is None:
        return opus
    return "%d #%d" % (opus, n)


def _name(q):
    nicks = q.get('nickname', [''])
    if len(nicks) > 1:
        print("%s dropping nicknames: %s and using '%s'" % (_title(q), nicks[1:], nicks[0]))
    n = ''
    try:
        n = nicks[0]
    except AttributeError:
        pass

    if '/' in n:
        n = n.split('/')[0]
    if n.lower().startswith('the '):
        n = n[4:]

    return n.lower()


def _key(q):
    # 50#4 is the only sharp (f-sharp minor)
    key = q['key']
    minor = key[0].islower()
    if 1 < len(key):
        if key[1] == 'b':
            key = key[0] + '-flat'
        elif key[1] == '#':
            key = key[0] + '-sharp'
    key = key.replace('-flat', '&flat;')
    key = key.replace('-sharp', '&sharp;')
    # majorminor = " minor" if minor else " Major"
    return key  #+ majorminor


def _minor(q):
    return q['key'][0].islower()

def _minuets(q):
    """returns the quartet movements with minuets"""
    m = q['movements']
    return [i['mvmt'] for i in m if 'Menu' in i['tempo'] or 'Scherzo' in i['tempo']]

def get_cmap(filename):
    """Returns a mapping of opus number to color name.
        This uses the color names generated by reportlab.lib.colors.describe.
    """
    global COLS
    COLS = read_colors(filename)

    name = os.path.splitext(os.path.basename(filename))[0]
    maps = {
        'Set3-11': {
              1: 'gainsboro',
              2: 'gainsboro',

              9: 'lemonchiffon',

             17: 'lightgrey',

             20: 'ReportLabLightBlue',

             33: 'salmon',

             42: 'light skyblue',
             50: 'light skyblue',

             54: 'dark skyblue',
             55: 'dark skyblue',

             64: 'salmon', # sandybrown

             71: 'darkkhaki',
             74: 'darkkhaki',

             76: 'orchid',

             77: 'mistyrose',
            103: 'mistyrose',
        },
        'Trello': {
            1: "silver",
            2: "silver",
            9: "olivedrab",
            17: "orange",
            20: "tomato",
            33: "gold",
            64: "gold",
            42: "orchid",
            50: "orchid",
            54: "hotpink",
            55: "hotpink",
            71: "darkturquoise",
            74: "darkturquoise",
            76: "mediumaquamarine",
            77: "darkcyan",
            103: "darkcyan"
        },
        'sashamaps2': {
             1: "grey",
             2: "grey",
             9: "red",
            17: "orange",
            20: "yellow",
            33: "lime",
            64: "lime",
            42: "green",
            50: "green",
            54: "cyan",
            55: "cyan",
            71: "teal",      # "blue",
            74: "teal",      # "blue",
            76: "lavender",  # "purple",
            77: "magenta",
           103: "magenta"
        },
        'sashamaps': {
             1: "grey",
             2: "grey",
             9: "red",
            17: "orange",
            20: "yellow",
            33: "cyan",
            64: "cyan",
            42: "magenta",  # 42: "lime",
            50: "lime",
            54: "green",
            55: "green",
            71: "teal",
            74: "teal",
            76: "lavender",
            77: "magenta",
           103: "magenta"
        },
    }

    defaults = {
        1: [1, 2],
        2: [9],
        3: [17],
        4: [20],
        5: [33, 64], # 33 and 64 have the same keys
        6: [42, 50],
        7: [54, 55],
        8: [71, 74],
        9: [76],
       10: [77, 103]
    }
    mapping = maps.get(name, {})
    if not mapping:
        print("no explicit mapping providing, going in order")
        for c in sorted(COLS.values(), key=lambda kv: kv['index']):
            for opus in defaults.get(c['index'], []):
                mapping[opus] = c['name']


    if len(COLS) < len(defaults):
        raise Exception("Insufficient colors provided! Need %d, got %d" % (
            len(defaults), len(COLS)))
    elif len(defaults) < len(COLS):
        print("Unused colors: %s" % (set(COLS.keys()) - set(mapping.values())))

    for (k, v) in mapping.items():
        if v not in COLS:
            raise Exception("CMAP out of date! edit read.py:get_cmap()")

    print("Mapping for %s is: \n%s\n" % (name, json.dumps(mapping, indent=4)))

    return mapping


def print_colors(cols):
    """
    Takes a dict of colors that looks like this:
        {'transparent': {'index': 1,
          'value': Color(.019608,.058824,.172549,1),
          'lightness': 0.08366013071895424,
          'name': 'transparent',
          'name_quality': 0.1834},
    """
    for (name, info) in cols.items():
        print("{index:2d}: {name} [{name_quality:.2f}]".format(**info))


def write_sashamaps(l):
    """
    scrape the colors from https://sashamaps.net/docs/resources/20-colors/
    via cut/paste into a list, sm
    """
    sm = """"""  # blob omitted for brevity
    lines = sm.split("\n")[1:-2]
    cl = list(zip(lines[::3], lines[1::3], lines[2::3]))

    def to_rgba(s):
        c =  colors.HexColor(s)
        return (int(255*c.red), int(255*c.green), int(255*c.blue), 1)

    for name, hexv, six in cl:
        name = name.lower()
        ix = int(six)  # don't really need the string index
        rgba = "rgba(%d, %d, %d, %d)" % to_rgba(hexv)
        parsed.append(dict(name=name, index=ix, value=rgba))

    with open('colors/sashamaps.json', 'w') as f:
        json.dump(dict(colors=parsed, name="sashamaps", key=None), f, indent=4)

    # after writing this code I organized the colors in the "rainbow" layout
    # using row order 1, 0, 2 (main row first)
    # and removed the "index" field which I wasn't using and just got confusing.


def read_colors(filename='Set3-11.json'):
    """
    Takes a json file from loading.io (e.g. https://loading.io/color/feature/Set3-11/)
    and reads it into a set of reportlab colors

    TODO: the colors here look interesting and there are 20! https://sashamaps.net/docs/resources/20-colors/
    """
    with open(filename) as f:
        cset = json.load(f)

    def parse_color(s):
        # 'rgba(141, 211, 199, 1)'
        r, g, b, a = s[5:-1].split(', ')
        channel = lambda c: int(c) / 255.0
        return colors.Color(channel(r), channel(g), channel(b), int(a))

    cvalues = [parse_color(c['value']) for c in cset['colors']]
    print("Read %d colors from %s" % (len(cvalues), filename))

    lightness = lambda c: colors.color2bw(c).red
    cols = {}
    for ix, c in enumerate(cset['colors'], 1):
        color = parse_color(c['value'])
        l = lightness(color)
        name, quality = c.get('name'), 1
        if not name:
            desc = colors.describe(color, mode=1)  # 'best match is cornflowerblue, distance 0.0000'
            comma = desc.index(',')
            name, quality = desc[len("best match is "):comma], float(desc[comma + len(" distance ") + 1:])
        col = dict(
            index=ix,
            value=color,
            lightness=l,
            name=name,
            name_quality=quality
        )

        if name in cols:
            col1 = cols[name]
            prefixes = ('light ', 'dark ') if col1['lightness'] <= l else ('dark ', 'light ')
            name1, name2 = [p + name for p in prefixes]
            col['name'] = name2

            del cols[name]
            col1['name'] = name1
            cols[name1] = col1

        cols[col['name']] = col

    print("returning %d colors" % (len(cols)))
    return cols


def _bgcolor(q):
    color_name = CMAP.get(q['opus'], 'white')
    return COLS.get(color_name, dict(value=colors.white))['value']


def _add_extras(quartets):
    mozarts = [
        dict(composer='Mozart', opus='K387', key='G', nickname=["Spring"]),
        dict(composer='Mozart', opus='K421', key='d', nickname=[""]),
        dict(composer='Mozart', opus='K428', key='E-flat', nickname=[""]),
        dict(composer='Mozart', opus='K458', key='B-flat', nickname=["Hunt"]),
        dict(composer='Mozart', opus='K464', key='A', nickname=[""]),
        dict(composer='Mozart', opus='K465', key='C', nickname=["Dissonance"]),
    ]

    op42 = [i for (i, q) in enumerate(quartets) if q.get('ID', 0) == '042'][0]
    quartets = quartets[:op42] + mozarts + quartets[op42:]

    beethovens = [
        {'composer': 'Beethoven', 'opus': 18, '#': 1, 'key': 'F', 'nickname': ['How do you like &hellip;?']},
        {'composer': 'Beethoven', 'opus': 18, '#': 2, 'key': 'G', 'nickname': ['The Compliment']},
        {'composer': 'Beethoven', 'opus': 18, '#': 3, 'key': 'D'},
        {'composer': 'Beethoven', 'opus': 18, '#': 4, 'key': 'c'},
        {'composer': 'Beethoven', 'opus': 18, '#': 5, 'key': 'A'},
        {'composer': 'Beethoven', 'opus': 18, '#': 6, 'key': 'B-flat'},
    ]
    op103 = [i for (i, q) in enumerate(quartets) if q.get('ID', 0) == '103'][0]
    quartets = quartets[:op103] + beethovens + quartets[op103:]

    return quartets

def write_haydn_peters_ix(datafile='./../quartet-chooser/src/data/data.json', outfile='haydn_peters.json'):
    """
    reads data from quartet roulette and writes out an index.
    maps quartet id to peters volume
    """
    with open(datafile) as f:
        d = json.load(f)

    haydn = [q for q in d['greats'] if q['composer'] == 'Haydn']

    def ID(q):
        opus = int(q['catalog'].replace('Opus ', ''))
        number = ('_'  + q['work_number']) if q['work_number'] else ''
        return "%03d%s" % (opus, number)

    def volume(q):
        n = q['notes']
        marker = 'Peters Volume '
        ix = n.find(marker)
        if 0 < ix:
            s = n[ix + len(marker):ix + len(marker) + 1]
            return int(s)

    with open(outfile, 'w') as f:
        json.dump(peters, f, indent=4)


# more colors: https://sashamaps.net/docs/resources/20-colors/
def get_data(quartet_file='quartets.json', peters='haydn_peters.json', movement_file='movements.json', colorf='colors/Set3-11.json', extend=True):
    """#quartets.json sample entry
    {
        'ID': '076_2',
        '#': 2,
        'score': '/Users/jason/Dropbox/Code/haydn/scores (pdf)/076_2.pdf',
        'opus': 76,
        'parts': {
            'V1': '/Users/jason/Dropbox/Code/haydn/parts/076_2_V1.pdf',
            'V2': '/Users/jason/Dropbox/Code/haydn/parts/076_2_V2.pdf',
            'VC': '/Users/jason/Dropbox/Code/haydn/parts/076_2_VC.pdf',
            'VA': '/Users/jason/Dropbox/Code/haydn/parts/076_2_VA.pdf'
        },
        'key': 'd',
        'hoboken': 76,
        'nickname': ['Quinten / (Fifths)']
    }
    """
    """# movements.json sample entry
    {
        "mode_confidence": 0.734,
        "is_variation": "no",
        "pitch_extremes": {
            "V1": [
                "G3",
                "E-6"
            ],
            "V2": [
                "G3",
                "A-5"
            ],
            "VC": [
                "E-2",
                "E-4"
            ],
            "VA": [
                "E-3",
                "E-5"
            ]
        },
        "mvmt": 1,
        "measures": 92,
        "tempo": "Presto",
        "time_signature_confidence": 0.99,
        "music_xml": "/Users/jason/Dropbox/Code/haydn/musicxml/001_0m1.xml",
        "meter": [
            2,
            4
        ],
        "key": 3,
        "duration": 173.70667,
        "en_analysis": "/Users/jason/Dropbox/Code/haydn/data/en_analyses/001_0m1.mp3.json",
        "loudness_max": -12.315,
        "ID": "001_0m1",
        "begin_key": "Eb",
        "overall_loudness": -23.51,
        "recording": "/Users/jason/Dropbox/Code/haydn/../../Public/haydn/angeles/001_0m1.mp3",
        "#": 0,
        "key_confidence": 0.943,
        "bpm": 135.983,
        "end_key": "Eb",
        "opus": 1,
        "loudness_min": -41.928,
        "mode": 1,
        "time_signature": 4,
        "actual_duration": 162.737,
        "energy": 0.18874,
        "danceability": 0.43146
    },
    """


    # this isn't used here; it's a bit gross to have the side effect of loading
    # it here just to avoid doing it later. TODO: clean up?
    global CMAP
    CMAP = get_cmap(colorf)

    with open(peters) as f:
        p_ix = json.load(f)

    with open(movement_file) as f:
        movements = defaultdict(list)
        qid = lambda m: m['ID'].split('m')[0]
        for m in json.load(f):
            movements[qid(m)].append(m)

    with open(quartet_file) as f:
        data = json.load(f)
        quartets = []
        # some nicknames are missing; others need shortening
        # I'm trying to make quartet roulette the authoritative source for nicknames
        # and just copy things here.
        rename = {
            '001_0': "Naught Bad",  # TODO: this isn't anywhere else; update sources when official
            '001_3': "Da Capo",     # Updated Quartet Roulette backing data with this.
            '017_1': "I told you not to...", # I told you not to (do)!
            '033_4': "Jackalope",
            '050_2': "Oh No! / Pre-Primp",
            '050_3': "Primp",
            '050_4': "Shrimp",
            '055_3': "Wood Thrush",
            '064_1': "Quinky",  # as of 7/15/24 this isn't on quartetroulette. It comes from a misreading of "Quirky" in Andy Stein's music ... reported by EL.
            '064_2': "Lemon",
            '064_6': "Caped Avenger",
            '076_1': "jack-in-the-box",
            '076_6': "Scales to...", # scales to neverland
            '077_2': "tortoise & hare", # tortoise and the hare
        }
        for k, v in sorted(data.items(), key=lambda kv: kv[0], reverse=False):
            # data has 71 quartets; get rid of opus 2#3 and 2#5, and 1#5.
            if k not in {'001_5', '002_3', '002_5'}:
                # make some nicknames shorter:
                if k in rename:
                    v['nickname'] = [rename[k]]
                v['ID'] = k
                v['peters'] = p_ix.get(k)
                v['composer'] = 'Haydn'
                v['movements'] = movements[k]

                quartets.append(v)

        # add a count field so we know how many other quartets are in this key
        keys = defaultdict(list)
        for q in quartets:
            keys[q['key']].append(q['ID'])

        key_count = Counter(q['key'] for q in quartets)
        for q in quartets:
            k = q['key']
            q['key_number'] = 1  + keys[k].index(q['ID'])
            q['key_count'] = key_count[k]

        return _add_extras(quartets) if extend else quartets
